"""
This module contains rules for working with java projects
"""

load("@bazel_skylib//lib:collections.bzl", "collections")
load("@rules_java//java:defs.bzl", "java_test")

JUNIT_JUPITER_DEPS = [
    "@maven//:org_junit_jupiter_junit_jupiter_api",
    "@maven//:org_junit_jupiter_junit_jupiter_engine",
    "@maven//:org_junit_jupiter_junit_jupiter_params",
]

JUNIT_PLATFORM_DEPS = [
    "@maven//:org_junit_platform_junit_platform_commons",
    "@maven//:org_junit_platform_junit_platform_console",
    "@maven//:org_junit_platform_junit_platform_engine",
    "@maven//:org_junit_platform_junit_platform_launcher",
    "@maven//:org_junit_platform_junit_platform_suite_api",
]

JUNIT_EXTRA_DEPS = [
    "@maven//:org_apiguardian_apiguardian_api",
    "@maven//:org_opentest4j_opentest4j",
    "@maven//:org_skyscreamer_jsonassert",
]

def _javalint(ctx, srcs):
    """Generates a test action linting the input files.

    Args:
      ctx: analysis context.
      srcs: list of source files to be checked.
    Returns:
      A script running javalint on the input files.
    """
    java_runtime_info = ctx.attr._javabase[java_common.JavaRuntimeInfo]
    args = ["--dry-run", "--set-exit-if-changed"]

    for f in srcs:
        args.append(f.path)

    return "PATH=\"{path}/bin:$PATH\" ; {java} --add-exports jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
            --add-exports jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
            --add-exports jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
            --add-exports jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
            --add-exports jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED \
            -jar {linter} {args}".format(
        java = java_runtime_info.java_executable_exec_path,
        path = java_runtime_info.java_home,
        linter = ctx.executable._javalint_tool.short_path,
        args = " ".join(args),
    )

def _javalint_fix_impl(ctx):
    java_runtime_info = ctx.attr._javabase[java_common.JavaRuntimeInfo]

    # Much of the following is lifted from:
    # https://cs.opensource.google/bazel/bazel/+/refs/tags/4.0.0:src/main/java/com/google/devtools/build/lib/bazel/rules/java/java_stub_template.txt;l=114
    content = """#!/bin/bash
# Find our runfiles tree.
#
# Call this program X.  X was generated by a rule.
# X may be invoked in many ways:
#   1a) directly by a user, with $0 in the output tree
#   1b) via 'bazel run' (similar to case 1a)
#   2) directly by a user, with $0 in X's runfiles tree
#   3) by another program Y which has a data dependency on X, with $0 in Y's runfiles tree
#   4) via 'bazel test'
#   5) by a genrule cmd, with $0 in the output tree
#   6) case 3 in the context of a genrule
#
# For case 1, $0 will be a regular file, and the runfiles tree will be
# at $0.runfiles.
# For case 2, $0 will be a symlink to the file seen in case 1.
# For case 3, we use Y's runfiles tree, which will be a superset of X's.
# For case 4, $JAVA_RUNFILES and $TEST_SRCDIR should already be set.
# Case 5 is handled like case 1.
# Case 6 is handled like case 3.
self="$0"
if [[ "$self" != /* ]]; then
  self="$PWD/$self"
fi
if [[ -z "$RUNFILES" ]]; then
while true; do
  if [[ -e "$self.runfiles" ]]; then
    RUNFILES="$self.runfiles"
    break
  fi
  if [[ $self == *.runfiles/* ]]; then
    RUNFILES="${{self%%.runfiles/*}}.runfiles"
    break
  fi
  if [[ ! -L "$self" ]]; then
    break
  fi
  readlink="$(readlink "$self")"
  if [[ "$readlink" = /* ]]; then
    self="$readlink"
  else
    # resolve relative symlink
    self="${{self%%/*}}/$readlink"
  fi
done
if [[ -z "$RUNFILES" ]]; then
  echo 'Cannot locate runfiles directory.'
  exit 1
fi
fi
# This is the end of the portion copied from the java_stub_template - what's below is original code.
BUILD_DIR="$BUILD_WORKSPACE_DIRECTORY"
if [ -n "$BUILD_DIR" ]; then
  BUILD_DIR="$BUILD_DIR/"
fi
TOOL={executable}
JAVA={java}
if [[ ! -f "$TOOL" ]]; then
  # The path to the tool contains starts with `/external` but when
  # using --nolegacy_external_runfiles we need to strip that from
  # the path.
  TOOL="$RUNFILES/${{TOOL/#external\\///}}"
  if [[ ! -f "$TOOL" ]]; then
    echo "Cannot locate linter. $TOOL"
    exit 2
  fi
fi
SRCS=({srcs})
SRCS=${{SRCS[@]/#/$BUILD_DIR}}
java \
    --add-exports jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
    --add-exports jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
    --add-exports jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
    --add-exports jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
    --add-exports jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED \
    -jar "$TOOL" --replace $SRCS
""".format(
        java = java_runtime_info.java_executable_exec_path,
        path = java_runtime_info.java_home,
        executable = ctx.executable._javalint_tool.path,
        srcs = " ".join([src.path for src in ctx.files.srcs]),
    )

    content = ctx.expand_location(content, [ctx.attr._javalint_tool])

    executable = ctx.actions.declare_file("%s-lint-fix" % ctx.label.name)
    ctx.actions.write(
        output = executable,
        content = content,
        is_executable = True,
    )
    runfiles = ctx.runfiles(files = [ctx.executable._javalint_tool])

    return [
        DefaultInfo(
            executable = executable,
            runfiles = runfiles,
        ),
    ]

javalint_fix = rule(
    _javalint_fix_impl,
    attrs = {
        "srcs": attr.label_list(
            allow_files = [".java"],
            doc = "Source files to review and fix",
            mandatory = True,
            allow_empty = False,
        ),
        "_javabase": attr.label(
            default = "@bazel_tools//tools/jdk:current_java_runtime",
        ),
        "_javalint_tool": attr.label(
            default = "@com_google_googlejavaformat//file",
            executable = True,
            cfg = "target",
        ),
    },
    executable = True,
    doc = "Lint Kotlin files and automatically fix them as needed",
)

def _javalint_test_impl(ctx):
    script = _javalint(
        ctx,
        srcs = ctx.files.srcs,
    )

    ctx.actions.write(
        output = ctx.outputs.executable,
        content = script,
    )

    files = [ctx.executable._javalint_tool] + ctx.files.srcs

    return [
        DefaultInfo(
            runfiles = ctx.runfiles(
                files = files,
                transitive_files = ctx.attr._javabase[java_common.JavaRuntimeInfo].files,
            ).merge(ctx.attr._javalint_tool[DefaultInfo].default_runfiles),
            executable = ctx.outputs.executable,
        ),
    ]

javalint_test = rule(
    _javalint_test_impl,
    attrs = {
        "srcs": attr.label_list(
            allow_files = [".java"],
            doc = "Source files to lint",
            mandatory = True,
            allow_empty = False,
        ),
        "_javabase": attr.label(
            default = "@bazel_tools//tools/jdk:current_java_runtime",
        ),
        "_javalint_tool": attr.label(
            default = "@com_google_googlejavaformat//file",
            executable = True,
            cfg = "host",
        ),
    },
    doc = "Lint Java files, and fail if the linter raises errors.",
    test = True,
    toolchains = [
        "@bazel_tools//tools/jdk:toolchain_type",
    ],
)

def java_lint(name, srcs = None, visibility = None):
    if not srcs:
        srcs = native.glob([
            "src/main/java/**/*.java",
            "src/test/java/**/*.java",
        ])

    javalint_test(
        name = "%s_test" % name,
        srcs = srcs,
        visibility = visibility,
    )

    javalint_fix(
        name = "%s_fix" % name,
        srcs = srcs,
        visibility = visibility,
    )

def java_junit5_test(name, srcs, test_package, deps = [], runtime_deps = [], **kwargs):
    """JUnit5 test

    Args:
        name: test name
        srcs: test srcs
        test_package: test package name
        deps: test deps
        runtime_deps: runtime deps
        **kwargs: other args
    """
    FILTER_KWARGS = [
        "main_class",
        "use_testrunner",
        "args",
    ]

    for arg in FILTER_KWARGS:
        if arg in kwargs.keys():
            kwargs.pop(arg)

    junit_console_args = []
    if test_package:
        junit_console_args += ["--select-package", test_package]
    else:
        fail("must specify 'test_package'")
    java_test(
        name = name,
        srcs = srcs,
        use_testrunner = False,
        main_class = "org.junit.platform.console.ConsoleLauncher",
        args = junit_console_args,
        deps = collections.uniq(deps + JUNIT_JUPITER_DEPS + JUNIT_PLATFORM_DEPS + JUNIT_EXTRA_DEPS),
        runtime_deps = collections.uniq(runtime_deps + JUNIT_PLATFORM_DEPS),
        **kwargs
    )
